name: Get version for applications

# Controls when the action will run. Triggers the workflow on push or pull request
on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      environment_short:
        required: true
        type: string
    outputs:
      env_tag:
        description: 'The new version of the application'
        value: ${{ jobs.get_version.outputs.new_version }}
      current_tag:
        description: 'The current version of the application'
        value: ${{ jobs.get_version.outputs.current_version }}
      sha:
        description: 'The current sha of the code'
        value: ${{ jobs.get_version.outputs.sha }}
      sha_short:
        description: 'The current sha short of the code'
        value: ${{ jobs.get_version.outputs.sha_short }}


# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  get_version:
    runs-on: ubuntu-latest
    timeout-minutes: 80
    environment: ${{ inputs.environment }}
    outputs:
      sha: ${{ steps.determine_bump.outputs.sha }}
      sha_short: ${{ steps.determine_bump.outputs.sha_short }}
      new_version: ${{ steps.determine_bump.outputs.new_version }}
      current_version: ${{ steps.determine_bump.outputs.current_version }}
    permissions:
      contents: read
      pull-requests: read
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - uses: actions/github-script@v7
        id: get_pr_data
        with:
          script: |
            return (
              await github.rest.repos.listPullRequestsAssociatedWithCommit({
                commit_sha: context.sha,
                owner: context.repo.owner,
                repo: context.repo.repo,
              })
            ).data[0];

      - name: Pull Request data
        id: show-pr-data
        run: |
          echo "${{ fromJson(steps.get_pr_data.outputs.result).number }}"
          echo "${{ fromJson(steps.get_pr_data.outputs.result).title }}"
          echo "pr_number=${{ fromJson(steps.get_pr_data.outputs.result).number }}" >> $GITHUB_OUTPUT
          echo "pr_title=${{ fromJson(steps.get_pr_data.outputs.result).title }}" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: previoustag
        run: |
          tag=$(git describe --tags $(git rev-list --tags --max-count=1))
          echo "tag=$tag" >> $GITHUB_OUTPUT

      - name: Get LABELS
        id: get-labels
        env:
          PR_NUMBER: ${{ steps.show-pr-data.outputs.pr_number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "The Pull request Number for labels getting is ${{ env.PR_NUMBER }}"
          gh api -H "Accept: application/vnd.github+json" /repos/ras-devops/novu/issues/${{ env.PR_NUMBER }}/labels | jq '[.[].name]' > /tmp/label_list

      - name: Semantic Custom Version Bumping
        uses: ras-devops/determine-version-bump@v1.0.10
        id: determine_bump
        with:
          current_version: ${{ steps.previoustag.outputs.tag }}
          list_labels_file_patch: /tmp/label_list

#      - name: Determine Version Bump
#        id: determine_bump
#        run: |
#          labels=$(cat /tmp/label_list)
#          current_version="${{ steps.previoustag.outputs.tag }}"
#          validate_version() {
#            local version="$1"
#            regex="^v?([0-9]+\.){2}[0-9]+(-[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*)?(\+[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*)?$"
#
#            if [[ $version =~ $regex ]]; then
#              echo "Valid version: $version"
#            else
#              echo "Invalid version: $version"
#              exit 1
#            fi
#          }
#
#          validate_version "$current_version"
#          # Determine the bump type (major, minor, patch, or build)
#          if [[ $labels == *"bump:major"* ]]; then
#            bump_type="major"
#          elif [[ $labels == *"bump:minor"* ]]; then
#            bump_type="minor"
#          elif [[ $labels == *"bump:patch"* ]]; then
#            bump_type="patch"
#          else
#            echo "No version bump labels found. Bumping build number."
#            bump_type="build"
#          fi
#
#          # Determine prerelease type and build number
#          prerelease_label=$(echo $current_version | awk -F- '{print $2}' | awk -F. '{print $1}')
#          build_number=$(echo $current_version | sed -n 's/.*-'"$prerelease_label"'\.\([0-9]\{1,\}\)/\1/p')
#
#          echo "prerelease_label: $prerelease_label"
#          echo "build_number: $build_number"
#
#          # If there are no labels and no prerelease part, create prerelease alpha with build number 0
#          if [ -z "$labels" ] && [ -z "$prerelease_label" ]; then
#            new_prerelease_label="alpha"
#            new_build_number=0
#          elif [ -z "$prerelease_label" ]; then
#            # If prerelease suffix doesn't exist, create default prerelease alpha with build number 0
#            new_prerelease_label="alpha"
#            new_build_number=0
#          fi
#
#          # If prerelease labels are present, prioritize them
#          if [ -n "$labels" ]; then
#            if [[ $labels == *"pre:demo"* ]]; then
#              new_prerelease_label="demo"
#            elif [[ $labels == *"pre:beta"* ]] && [[ $prerelease_label == "demo" ]]; then
#              new_prerelease_label="demo"
#            elif [[ $labels == *"pre:alpha"* ]] && [[ $prerelease_label == "demo" ]]; then
#              new_prerelease_label="demo"
#            elif [[ $labels == *"pre:alpha"* ]] && [[ $prerelease_label == "beta" ]]; then
#              new_prerelease_label="beta"
#            elif [[ $labels == *"pre:beta"* ]] ; then
#              new_prerelease_label="beta"
#            fi
#          fi
#
#          # If prerelease labels are present, bump the build number only for the highest priority prerelease type
#          if [ -n "$new_prerelease_label" ] && ([ -z "$prerelease_label" ] || [ "$new_prerelease_label" != "$prerelease_label" ]); then
#            prerelease_label="$new_prerelease_label"
#            new_build_number=0
#          elif [ -n "$new_prerelease_label" ]; then
#            build_number=$((build_number + 1))
#          fi
#
#          # Bump major, minor, or patch version based on the determined bump type
#          case $bump_type in
#          "major")
#            new_version=$(echo $current_version | awk -F. '{print $1 + 1 ".0.0"}')
#            ;;
#          "minor")
#            new_version=$(echo $current_version | awk -F. '{print $1 "." $2 + 1 ".0"}')
#            ;;
#          "patch")
#            new_version=$(echo $current_version | awk -F. '{print $1 "." $2 "." $3 + 1}')
#            ;;
#          "build")
#            # If there are prerelease labels, include them in the new version
#            if [ -n "$prerelease_label" ] && [ -n "$new_build_number" ] ; then
#              new_version="${current_version%-*}-$prerelease_label.$new_build_number"
#            elif [ -n "$prerelease_label" ] && [ "$new_prerelease_label" == "$prerelease_label" ]; then
#              new_version="${current_version%-*}-$prerelease_label.$build_number"
#            elif [ -n "$prerelease_label" ] && [ -z "$new_prerelease_label" ] ; then
#              new_version="${current_version%-*}-$prerelease_label.$((build_number + 1))"
#            else
#              new_version="${current_version%-*}.$build_number"
#
#              # If there is no prerelease label, but the current version has the format "v0.25.17-alpha.1"
#              if [[ $current_version =~ -alpha.[0-9]+$ ]]; then
#                new_version="${current_version%-*}-alpha.$((build_number - 1))"
#              fi
#            fi
#            ;;
#          *)
#            echo "Invalid bump type"
#            exit 1
#            ;;
#          esac
#          validate_version "$new_version"
#          echo "Bumping $bump_type Version"
#          echo "Current Version: $current_version"
#          echo "Labels attached to the Pull Request: $labels"
#          echo "New Version: $new_version"
#          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
#          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
#          echo "new_version=$new_version" >> $GITHUB_OUTPUT
#          echo "current_version=$current_version" >> $GITHUB_OUTPUT
